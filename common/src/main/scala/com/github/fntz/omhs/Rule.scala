package com.github.fntz.omhs

import com.github.fntz.omhs.internal._
import io.netty.handler.codec.http.HttpMethod

import scala.collection.mutable.{ArrayBuffer => AB}

/**
 * This class is internal and will be autogenerated in compile-time
 * @see com.github.fntz.omhs.macros.RoutingImplicits
 * Describe rule with restrictions:
 *  - path
 *  - query
 *  - header
 *  - file
 *  - body
 *  - cookie
 *
 *  {{{
 *    val rule = Rule(HttpMethod.Get)
 *     .path("test").path(StringParam).path(LongParam)
 *     .body()(someReader)
 *     .header("User-Agent")
 *  }}}
 * @param method - http method where current rule will do
 */
class Rule {

  private var method: HttpMethod = HttpMethod.GET
  private val paths: AB[PathParam] = new AB[PathParam]()
  private val headers: AB[HeaderParam] = new AB[HeaderParam]()
  private val cookies: AB[CookieParam] = new AB[CookieParam]()

  private var reader: BodyReader[_] = _

  private var queryReader: QueryReader[_] = _

  private var fileParam: FileParam = _

  private var isBodyNeeded = false

  private var isQueryNeeded = false

  private var isFileNeeded = false

  private var isCurrentRequestNeeded: Boolean = false

  def isNeedToParseBody: Boolean = isBodyNeeded

  def isNeedToDecodeQuery: Boolean = isQueryNeeded

  def isNeedToPassCurrentRequest: Boolean = isCurrentRequestNeeded

  def isNeedToFetchFiles: Boolean = isFileNeeded

  def currentParams: Vector[PathParam] = paths.toVector

  def currentHeaders: Vector[HeaderParam] = headers.toVector

  def currentFileParam: FileParam = fileParam

  def currentBodyReader: BodyReader[_] = reader

  def currentQueryReader: QueryReader[_] = queryReader

  def currentCookies: Vector[CookieParam] = cookies.toVector

  def currentMethod: HttpMethod = method

  /**
   * build url (relative) from paths parameters
   * @return current url information which was provided with path-params
   */
  def currentUrl: String = {
    val tmp = currentParams.map {
      case HardCodedParam(v) => v
      case TailParam => "*"
      case AlternativeParam(xs) => s"${xs.mkString("|")}"
      case p: PathParam => s"{${p.name}}"
    }.mkString("/")
    if (tmp.startsWith("/")) {
      tmp
    } else {
      s"/$tmp"
    }
  }

  def withMethod(method: HttpMethod): Rule = {
    this.method = method
    this
  }

  def withRequest(): Rule = {
    isCurrentRequestNeeded = true
    this
  }

  def withFiles(fileParam: FileParam): Rule = {
    this.fileParam = fileParam
    isFileNeeded = true
    this
  }

  def body[T](implicit reader: BodyReader[T]): Rule = {
    this.reader = reader
    this.isBodyNeeded = true
    this
  }

  def query[T](implicit queryReader: QueryReader[T]): Rule = {
    this.queryReader = queryReader
    this.isQueryNeeded = true
    this
  }

  def path(x: String): Rule = {
    paths += HardCodedParam(x)
    this
  }

  def path(x: PathParam): Rule = {
    paths += x
    this
  }

  def cookie(cookie: CookieParam): Rule = {
    cookies += cookie
    this
  }

  def header(header: HeaderParam): Rule = {
    headers += header
    this
  }

  override def toString: String = {
    val tmpHeaders = s"\n headers: ${headers.mkString(", ")}"
    val tmpReq = s"\n useRequest: $isNeedToPassCurrentRequest"
    val tmpIsBodyNeeded = s"\n isBodyNeeded: $isBodyNeeded"
    val tmpMethod = s"\n ---- $method"
    val tmpPath = s"\n path: ${paths.mkString("/")}"
    val tmpCookies = s"\n cookies: ${cookies.mkString(", ")}"
    val tmpWithFile = s"\n file? $isFileNeeded"
    s"$tmpMethod $tmpPath $tmpHeaders $tmpReq $tmpIsBodyNeeded $tmpCookies $tmpWithFile"
  }

  def same: Rule = {
    same()
  }

  def same(clearParams: Boolean = false): Rule = {
    val rule = Rule(method)
    if (!clearParams) {
      paths.foreach { x => rule.path(x)}
    }
    headers.foreach { x => rule.header(x) }
    cookies.foreach { x => rule.cookie(x) }
    if (isBodyNeeded) {
      rule.body(currentBodyReader)
    }
    if (isQueryNeeded) {
      rule.query(currentQueryReader)
    }
    if (isFileNeeded) {
      rule.withFiles(fileParam)
    }
    if (isCurrentRequestNeeded) {
      rule.withRequest()
    }
    rule
  }

}
object Rule {
  // tmp
  def apply(method: HttpMethod): Rule = new Rule().withMethod(method)
}

